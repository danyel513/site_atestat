<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    

    <!-- Website Title -->
    <title>PROBLEME INFORMATICA</title>
    
    <!-- Styles -->
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap&subset=latin-ext" rel="stylesheet">
    <link href="css/bootstrap.css" rel="stylesheet">
    <link href="css/fontawesome-all.css" rel="stylesheet">
    <link href="css/swiper.css" rel="stylesheet">
	<link href="css/magnific-popup.css" rel="stylesheet">
	<link href="css/styles.css" rel="stylesheet">
	
	<!-- Favicon  -->
    <link rel="icon" href="images/LIMBAJUL C++.png">
</head>

<body data-spy="scroll" data-target=".fixed-top">
    
    <!-- Preloader -->
	<div class="spinner-wrapper">
        <div class="spinner">
            <div class="bounce1"></div>
            <div class="bounce2"></div>
            <div class="bounce3"></div>
        </div>
    </div>
    <!-- end of preloader -->
    

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark navbar-custom fixed-top">
        <div class="container">

            <!-- Text Logo -->
             <a class="navbar-brand logo-text page-scroll" href="index.html">PROBLEME INFORMATICA</a>

            
            <!-- Mobile Menu Toggle Button -->
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarsExampleDefault" aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-awesome fas fa-bars"></span>
                <span class="navbar-toggler-awesome fas fa-times"></span>
            </button>
            <!-- end of mobile menu toggle button -->

            <div class="collapse navbar-collapse" id="navbarsExampleDefault">
                <ul class="navbar-nav ml-auto">
                    
                    <li class="nav-item">
                        <a class="nav-link page-scroll" href="sdc.html">SIRURI DE CARACTERE</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link page-scroll" href="recursivitate.html">RECURSIVITATE</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link page-scroll" href="subprograme.html">SUBPROGRAME</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link page-scroll" href="lcf.html">LUCRU CU FISIERE</a>
                    </li>

                    <!-- Dropdown Menu -->          
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle page-scroll" id="navbarDropdown" role="button" aria-haspopup="true" aria-expanded="false">FOLOSITOARE</a>
                        <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                            <a class="dropdown-item" href="back.html"><span class="item-text">METODA BACKTRACKING</span></a>
                            <div class="dropdown-items-divide-hr"></div>
                            <a class="dropdown-item" href="greedy.html"><span class="item-text">METODA GREEDY</span></a>
                            <div class="dropdown-items-divide-hr"></div>
                            <a class="dropdown-item" href="pd.html"><span class="item-text">PROGRAMARE DINAMICA</span></a>
                            
                        </div>
                    </li>
                    <!-- end of dropdown menu -->

                </ul>
                <span class="nav-item">
                    <a class="btn-outline-sm" href="quiz.html">QUIZ</a>
                </span>
            </div>
        </div> <!-- end of container -->
    </nav> <!-- end of navbar -->
    <!-- end of navigation -->


    <!-- Header -->
    <header id="header" class="header">
        <div class="header-content">
            <div class="container">
                <div class="row">
                    <div class="col-lg-6 col-xl-5">
                        <div class="text-container">
                            <h1>SUBPROGRAME</h1>
                            <p class="p-large">Un subprogram este o colecție de tipuri de date, variabile, instrucțiuni care îndeplinesc o anumită sarcină (calcule, citiri, afișări), atunci când este apelat de un program sau de un alt subprogram. Se diferentiaza astfel doua tipuri de variabile, cele locale si cele globale.</p>
                            <a class="btn-solid-lg page-scroll" href="pb-sub.html">PROBLEME SI EXERCITII</a>
                            
                        </div> <!-- end of text-container -->
                    </div> <!-- end of col -->
                    <div class="col-lg-6 col-xl-7">
                        <div class="image-container">
                            <div class="img-wrapper">
                                <img class="img-fluid" src="images/im6.png" alt="alternative">
                            </div> <!-- end of img-wrapper -->
                        </div> <!-- end of image-container -->
                    </div> <!-- end of col -->
                </div> <!-- end of row -->
            </div> <!-- end of container -->
        </div> <!-- end of header-content -->
    </header> <!-- end of header -->
    <svg class="header-frame" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none" viewBox="0 0 1920 310"><defs><style>.cls-1{fill:#4da1ef;}</style></defs><title>header-frame</title><path class="cls-1" d="M0,283.054c22.75,12.98,53.1,15.2,70.635,14.808,92.115-2.077,238.3-79.9,354.895-79.938,59.97-.019,106.17,18.059,141.58,34,47.778,21.511,47.778,21.511,90,38.938,28.418,11.731,85.344,26.169,152.992,17.971,68.127-8.255,115.933-34.963,166.492-67.393,37.467-24.032,148.6-112.008,171.753-127.963,27.951-19.26,87.771-81.155,180.71-89.341,72.016-6.343,105.479,12.388,157.434,35.467,69.73,30.976,168.93,92.28,256.514,89.405,100.992-3.315,140.276-41.7,177-64.9V0.24H0V283.054Z"/></svg>
    <!-- end of header -->



    <!-- introducere -->
    <div class="cards-1">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <BR><BR><BR><BR>
                        <div class="above-heading">INTRODUCERE</div>
                    <h2 class="h2-heading">Anatomia unei functii in C++</h2><br>
                </div> <!-- end of col -->
            </div> <!-- end of row -->
            <div class="row">
            <div class="col-lg-12">  
    <p>Se dau două numere naturale n și m. Să se determine suma dintre oglinditul lui n și oglinditul lui m.<br></p>
                         
<b><font align=left>
<xmp>
                            #include <iostream>
                            using namespace std;
                                    
                            int ogl(int x)
                            {
                                int r = 0;
                                do
                                {
                                    r = 10 * r + x % 10;
                                    x /= 10;
                                } while(x != 0);
                                return r;
                            }
                                    
                            int main()
                            {
                                int n , m;
                                cin >> n >> m;
                                cout << ogl(n) + ogl(m);
                                return 0;
                            }
</xmp></b></font>
                  <p> 
                    <br>
                    <h2> Antetul functiei: <u>int ogl(int x).</u></h2><br>
                    <font align="left">
                    <li> funcția se numește ogl;</li>
                    <li> funcția are un parametru, x, de tip int. Parametrul este important, deoarece prin el se precizează care este numărul pentru care se determină oglinditul: o funcție poate avea mai mulți parametri;
                        parametrii care apar în antetul funcției se numesc parametri formali;
                        parametrii unei funcții se mai numesc și argumente;</li>
                    <li> funcția are un anumit tip, aici int, care precizează care este tipul rezultatului;</li>
                    </font>   
                    </p>
                    <br>
                    <p>
                    <h2>Corpul functiei</h2> <br>
                    <font align="left">
                    Funcția are un bloc de instrucțiuni, corpul funcției, delimitat de acolade {}, care precizează operațiile prin care se obține rezultatul. <br> Mai mult: <br>
                    <li> corpul funcției poate avea propriile variabile (aici r);</li>
                    <li> parametrii n, respectiv m, întâlniți în apel, se numesc parametri efectivi sau parametri actuali. Valorile parametrilor
                        actuali sunt cunoscute - valorile citite pentru cele două variabile;</li>
                        <li> în corpul funcției, parametrul se comportă ca o variabilă locală;</li>
                        <li> nu putem avea o variabilă locală cu același identificator ca parametrul;</li>
                        <li> în corpul funcției nu se cunosc valorile parametrilor formali. Funcția trebuie să determine rezultatul corect indiferent de valoarea lor;</li>
                        <li> rezultatul determinat în cadrul funcției este întors în programul apelant prin instrucțiunea return. Rezultatul este calculat în mod obișnuit în variabila r. Prin instrucțiunea return r;, valoarea curentă a variabilei r este returnată în programul apelant;</li>
                    
                    </font>
                </p>
                <br>
                <p>
                    <h2>Apelul functiei</h2> <br>
                    <font align="left">
                        În funcția main găsim apelul funcției ogl: <br> <br>
                    <li> apelul funcției se face într-o expresie: cout << ogl(n) + ogl(m);. Pentru operația de adunare, operanzii vor fi rezultatele apelurilor celor două funcții;</li>
                    <li> parametrii n, respectiv m, întâlniți în apel, se numesc parametri efectivi sau parametri actuali. Valorile parametrilor
                        actuali sunt cunoscute - valorile citite pentru cele două variabile;</li>
                    </font>
                </p> <br><br>
                <p>O rezolvare C/C++ care folosește funcții este următoarea:<br></p>
  
                <div class="col-lg-12" >
<b><font align=left>
    <xmp>
    #include <iostream>
        using namespace std;
        
        void citire(int & n, int x[])
        {
            cin  >> n;  
            for(int i = 0 ; i < n ; ++ i)
                cin >> x[i];
        }
        
        void sortare(int n, int x[])
        {
            bool sortat = false;
            while(! sortat)
            {
                sortat = true;
                for(int i = 0 ; i < n - 1 ; i++)
                    if(x[i] > x[i+1])
                    {
                        int aux = x[i];
                        x[i] = x[i+1];
                        x[i+1] = aux;
                        sortat = false;
                    }
            }
        }
        
        void afisare(int n, int x[])
        {
            for(int i = 0 ; i < n ; ++ i)
                cout << x[i] << " ";
        }
        
        int main(){
            int k, v[1005];
            citire(k , v);
            sortare(k , v);
            afisare(k , v);
            return 0;
        }
</xmp></b></font> 

                </div>
                <div class="col-lg-12">
                    <font align="left">
                        Putem observa următoarele: <br> <br>
                    <li> funcțiile citire, sortare și afisare nu returnează valori și au un tip al rezultatului special, void. Tipul void este un tip de date care nu conține valori și poate fi folosit tocmai în asemenea situații. Am putea spune că sunt de tip procedură;</li>
                    <li> apelul acestor funcții se face în instrucțiuni de sine stătătoare;</li>
                    <li> funcțiile au câte doi parametri, numărul de elemente ale tabloului și tabloul propriu zis. Pentru parametrul formal de tip tablou nu trebuie să fie precizată dimensiunea declarată a tabloului;</li>
                    <li> numele parametrilor actuali nu trebuie să fie aceiași cu cei ai parametrilor formali. Trebuie însă să corespundă numărul lor, tipul lor și ordinea;</li>
                    <li> parametrul actual de tip tablou nu conține []:
                        dacă am fi avut apelul citire(k , v[]); am fi obținut o eroare de sintaxă, sintagma v[] neavând înțeles;
                        dacă am fi avut apelul citire(k , v[k]); am fi obținut de asemenea eroare de sintaxă, v[k] fiind elementul de indice k din tabloul v, deci o variabilă de tip int, nu tablou;</li>
                    <li> observați prezența caracterului & înaintea parametrului formal n din antetul funcției citire. Acesta transformă parametrul formal într-o referință a parametrului actual, iar modificările făcute asupra parametrului formal n au loc de fapt asupra parametrului actual k din main;</li>
                
                </font>   
                </div>         
                </div>    
            </div> <!-- end of row -->
        </div> <!-- end of container -->
    </div> <!-- end of cards-1 -->
    <!-- end of introducere -->


    
    <div id="features" class="tabs">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    
                    <h2 class="h2-heading">Definirea și declararea unei funcții C/C++</h2>
                    <br><br>
                    <p> &nbsp; &nbsp; &nbsp; Una dintre regulile limbajului C/C++ este următoarea, și o știm foarte bine pentru variabile: Orice identificator, pentru a putea fi folosit, trebuie să fie mai întâi declarat. Această regulă este valabilă și pentru funcții, astfel că identificăm următoarele noțiuni, aparent asemănătoare. Buna lor înțelegere ne va scuti de numeroase erori!!
                        <li> definirea unei funcții înseamnă scrierea ei în întregime; este alcătuită din antetul funcției și din corpul funcției;</li>
                        <li> declararea unei funcții înseamnă să-i anunțăm existența. Declararea funcției se face într-o instrucțiune declarativă și se mai numește și prototip al funcției. Declararea funcției poate fi înlocuită de definirea ei.</li>
                        <br><br>
                        &nbsp; &nbsp; &nbsp; Să considerăm următorul exemplu, fără însemnătate practică: 
                        </p>
                       <xmp>
                        #include <iostream>
                        using namespace std;
                            
                            void F(){
                                cout << "Salut";
                            }
                            
                            int main(){
                                F();
                                return 0;
                            }
                       </xmp>
                       <p>
                        &nbsp; &nbsp; &nbsp; Programul este sintactic corect. Partea:<br><br> </p>
                        <xmp>
                            void F(){
                                cout << "Salut";
                            }
                        </xmp>
                        <p> reprezintă definirea funcției F(), dar tot aici are loc și declararea. Dacă schimbăm ordinea funcțiilor F() și main() obținem: </p>
                        <xmp>
                            #include <iostream>
                            using namespace std;
                                
                                int main(){
                                    F();
                                    return 0;
                                }
                                
                                void F(){
                                    cout << "Salut";
                                }   
                        </xmp>
                        <p> De data aceasta programul nu mai este corect; la compilare obținem următoarea eroare:</p>
                        <xmp>
                            ttt.cpp: In function 'int main()'':
                            ttt.cpp:6:7: error: 'F' was not declared in this scope
                                 F();
                                   ^
                            Compilation failed.   
                        </xmp>
                        <p> 
                            Constatăm că identificatorul F nu este declarat. El poate fi declarat precizând prototipul funcției înaintea funcției main() (practic, înainte de a o apela), ca mai jos:
                        </p>
                        <xmp>
                            #include <iostream>
                            using namespace std;
                                
                                void F();
                                
                                int main(){
                                    F();
                                    return 0;
                                }
                                
                                void F(){
                                    cout << "Salut";
                                }
                        </xmp>
                        <p> Observăm că prototipul (declararea) este o instrucțiune C++ obișnuită, care se termină cu ;!!</p>
                </div> <!-- end of col -->
            </div> <!-- end of row -->
            </div>
            </div>



    <!-- Details -->
    <div id="details" class="basic-1">
        <div class="container">
            <div class="row">
                <div class="col-lg-6">
                    <div class="text-container">
                        <h2>Variabile locale</h2>
                        <br>
                        <p> Variabilele locale se declară într-un anumit bloc al programului, în corpul unei funcții. Fie programul de mai jos:</p>
                        <br>
                        <font align="left"><xmp>
#include <iostream>
using namespace std;
                                
void F()
{
    int x;
    x = 5;
    cout << x << endl;
}
                                
int main()
{
    int y = 10;
    F();
    cout << y << endl;
    return 0;
}
                        </xmp></font>
                        <br><br><br>
                        <p> Variabilele x și y declarate în programul de mai sus sunt locale. Variabila x poate fi utilizată numai în funcție F(), iar variabila y numai în funcția main(). Mai mult, cele două variabile ar fi putut avea același nume și nu ar fi fost nicio confuzie.
                        <br>
                        Variabilele locale respectă următoarele reguli:   
                        </p>
                        <ul class="list-unstyled li-space-lg">
                            <li class="media">
                                <i class="fas fa-square"></i>
                                <div class="media-body"> li se alocă memorie în zona de stivă</div>
                            </li>
                            <br>
                            <li class="media">
                                <i class="fas fa-square"></i>
                                <div class="media-body"> sunt vizibile numai în blocul în care au fost declarate</div>
                            </li>
                            <br>
                            <li class="media">
                                <i class="fas fa-square"></i>
                                <div class="media-body"> durata de viață a lor este execuția instrucțiunilor din blocul în care au fost declarate</div>
                            </li>
                            <br>
                            <li class="media">
                                <i class="fas fa-square"></i>
                                <div class="media-body"> sunt inițializate cu valori aleatorii. Mai precis, standardul C++ nu garantează inițializarea lor cu o anumită valoare. Asta nu înseamnă că nu este posibil ca variabilele locale să fie inițializate de exemplu cu 0 într-o anumită implementare a compilatorului, dar nu ne putem baza pe acest lucru. Mai mult, compilatorul utilizat pe pbInfo nu inițializează variabilele locale cu o anumită valoare</div>
                            </li>
                        </ul>
                <p> <b>OBSERVATIE: </b> Parametrii formali ai unei funcții respectă proprietățile unei variabile locale. Nu vom putea declara în blocul funcției variabile cu același nume ca al parametrilor formali. </p>    
                </div> <!-- end of text-container -->
                </div> <!-- end of col -->
                <div class="col-lg-6">
                    <div class="text-container">
                        <h2>Variabile globale</h2>
                        <br>
                        <p> Variabilele globale se declară în afara oricărei funcții. La declarare, ele sunt inițializate cu 0.</p>
                        <font align="left"><xmp>
#include <iostream>
using namespace std;
                                
int x;
                                
void F()
{
    cout << x << endl;
    x = 10;
}
                                
int y;
                                
int main()
{
cout << x << " " << y << endl;
x = 5; y = 15;
F();
cout << x << " " << y << endl;
return 0;
}
                        </xmp></font>
                        <p> În programul de mai sus variabilele x și y sunt globale. Variabila x poate fi utilizată atât în funcția main() cât și in F(), iar variabila y numai în main().
                        <br>
                        Variabilele globale respectă următoarele reguli:   
                        </p>
                        <ul class="list-unstyled li-space-lg">
                            <li class="media">
                                <i class="fas fa-square"></i>
                                <div class="media-body"> li se alocă memorie în zona de date</div>
                            </li>
                            <br>
                            <li class="media">
                                <i class="fas fa-square"></i>
                                <div class="media-body"> sunt vizibile în toate funcțiile care urmează în codul sursă declarării lor</div>
                            </li>
                            <br>
                            <li class="media">
                                <i class="fas fa-square"></i>
                                <div class="media-body"> durata de viață a lor este execuția întregului program</div>
                            </li>
                            <br>
                            <li class="media">
                                <i class="fas fa-square"></i>
                                <div class="media-body"> sunt inițializate cu valoarea 0.</div>
                            </li>
                        </ul>
                <p> <b>OBSERVATIE: </b> Într-un program putem avea și variabile globale și variabile locale, ba chiar variabile globale și locale cu același nume. Următorul program exemplifică această situație. Rulați-l și analizați valorile afișate pentru a deduce modul în care sunt ele vizibile! </p>    
                </div> <!-- end of text-container -->
                </div> <!-- end of col -->
                <div class="col-lg-12">
                    <div class="text-container">
                              <br><br>
                        <xmp>
                            #include <iostream>
                            using namespace std;
                                
                                int x;
                                
                                void F(){
                                    cout << x << endl; //5, variabila globala
                                    int x = 10;
                                    cout << x << endl; //10, variabila locala in F()
                                    {
                                        int x = 20;
                                        cout << x << endl; //20, variabila locala în F(), blocul interior
                                    }
                                    cout << x << endl; //10, variabila locala in F()
                                }
                                
                                int y;
                                
                                int main(){
                                    cout << x << endl; //0, variabila globală
                                    x = 5;
                                    cout << x << endl; //5, variabila globala
                                    F();
                                    cout << x << endl; //5, variabila globala
                                    int x = 100;
                                    cout << x << endl; //100, variabila locala in main()
                                    return 0;
                                }  
                        </xmp>
                            &nbsp;  &nbsp;  
                            <b>OBSERVATII:</b> <br>
                            <ol>
                            <li>  Dacă într-un program avem variabile cu același nume, dar cu domenii de vizibilitate diferite, are prioritate variabila cu domeniul de vizibilitate cel mai mic. În particular, dacă ave o variabilă globală și una locală cu același nume are prioritate variabila locală.</li>
                            <li> Dacă declarăm o variabilă în expresia de inițializare a unei instrucțiuni for, ea va fi vizibilă numai în expresiile de control ale instrucțiunii for și în blocul subordonat acesteia. De exemplu:</li>
                            </ol>
                        <xmp> 
                            for(int i =1 ; i <= 10 ; i ++)
                            cout << i << " " ;
                        </xmp>
                    </div> <!-- end of text-container -->
                </div> <!-- end of col -->
            </div> <!-- end of row -->
        </div> <!-- end of container -->
    </div> <!-- end of basic-1 -->
    <!-- end of details -->


    <!-- Video -->
    <div id="video" class="basic-2">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <h2>Videoclip sugestiv care conține explicații despre capitolul SUBPROGRAME:</h2> <br>
                    <!-- Video Preview -->
                    <div class="image-container">
                        <div class="video-wrapper">
                            <a class="popup-youtube" href="https://www.youtube.com/watch?v=gU1nPQyjXzE" data-effect="fadeIn">
                                <img class="img-fluid" src="images/video-image.png" alt="alternative">
                                <span class="video-play-button">
                                    <span></span>
                                </span>
                            </a>
                        </div> <!-- end of video-wrapper -->
                    </div> <!-- end of image-container -->
                    <!-- end of video preview -->

                    <div class="p-heading">Materialul video conține informații suplimentare și explicații bine structurate despre functionalitatea subprogramelor, dar si exemple sugestive.</div>        
                </div> <!-- end of col -->
            </div> <!-- end of row -->
        </div> <!-- end of container -->
    </div> <!-- end of basic-2 -->
    <!-- end of video -->

 

    <div class="ex-basic-2">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="text-container">
                        <h2>Transmiterea parametrilor</h2><br>
                        <p>Să ne amintim că parametri din antetul unei funcții se numesc parametri formali, iar cei din apelul funcției se numesc parametri efectivi.
                            <br>
                            <br>
                            <h3><i>Corespondența dintre parametri formali și cei efectivi</i></h3>
                            <p>Fie următorul program, în care funcția cmmdc returnează cel mai mare divizor comun al parametrilor:</p>
                        <xmp>
                            #include <iostream>
                            using namespace std;
                                
                                int cmmdc(int a , int b){
                                    while(b != 0)
                                    {
                                        int r = a % b;
                                        a = b;
                                        b = r;
                                    }
                                    return a;
                                }
                                
                                int main(){
                                    int x = 24, y = 18;
                                    cout << cmmdc(x , y) << endl; // 6
                                    cout << cmmdc(x, y + 2) << endl; // 4
                                    cout << cmmdc(x , 36) << endl; // 12
                                    cout << cmmdc(26 , 39) << endl; // 13
                                    cout << cmmdc(8.5 , 12.56) << endl; // 4
                                    return 0;
                                }
                        </xmp>
                        <p> Să observăm că între parametri formali și cei actuali trebuie să existe o anumită corespondență, astfel:</p>
                        <ol>
                            <li> numărul parametrilor formali și cel al parametrilor actuali trebuie să fie același (există și o excepție care depășește cadrul acestui articol)</li>
                            <li>tipul parametrilor formali trebuie să fie același cu cel al parametrilor actuali, sau să se poată face o conversie implicită</li>
                            <ul>
                                <li> cmmdc(x , y) - parametri actuali sunt variabile de tip int</li>
                                <li> cmmdc(x, y + 2) - un parametru actual este variabilă de tip int, celălalt este o expresie al cărei rezultat este de tip int</li>
                                <li> cmmdc(26 , 39) - parametri actuali sunt constante de tip int</li>
                                <li> cmmdc(8.5 , 12.56) - parametri actuali sunt constante de tip double. Înainte de apel valorile parametrilor actuali vor fi convertite la tipul int, apelul fiind similar cu cmmdc(8 , 12).</li>
                            </ul>

                            <li> numele parametrilor formali nu trebuie să fie aceiași cu numele parametrilor actuali corespunzători</li>
                        </ol>
                        Parametrii formali ai unei funcții se comportă la fel ca niște variabile locale:
                        <li> li se alocă memorie pe stivă, ca variabilelor locale.</li>
                        <li> devin variabile locale pentru funcție, iar numele acestor variabile este identic cu numele parametrilor din antetul funcției</li>
                        <li> la revenirea din apelul funcției, conținutul parametrilor, la fel ca al variabilelor locale, se pierde</li>
                    </p>
                    <br><br>
                    <h2>Mecanismele de transmitere a parametrilor în C++</h2>
                    <h4>A. Transmiterea prin valoare</h4> <br>
                    <p> În cazul transmiterii parametrilor prin valoare, parametrii formali ai unei funcții sunt copii ale valorilor parametrilor actuali. Acest lucru înseamnă că:</p>
                    <li> parametri actuali pot fi expresii ale căror valori corespund ca tip cu parametri formali (sau pot fi convertite implicit la tipul parametrilor formali).</li>
                    <li> pe stivă se memorează valoare expresiei (sau variabilei) date ca parametru actual.</li>
                    <li> la ieșirea din apelul funcției modificările realizate în funcție asupra parametrilor formali nu au efect asupra parametrilor actuali. Parametrii actuali sunt nemodificați!</li>
                    <li> acesta este modul implicit de transmitere a parametrilor.</li>
                    <br>
                    <h5>EXEMPLU:</h5> 
                    <xmp>
                        #include <iostream>
                        using namespace std;
                            
                            int cmmdc(int a , int b){
                                cout << "La inceputul functiei cmmdc, a = " << a << " si b = " << b << endl;
                                while(b != 0)
                                {
                                    int r = a % b;
                                    a = b;
                                    b = r;
                                }
                                cout << "La finalul functiei cmmdc, a = " << a << " si b = " << b << endl;
                                return a;
                            }
                            
                            int main(){
                                int x = 24, y = 18;
                                cout << cmmdc(x , y) << endl;
                                cout << "După apelul functiei cmmdc, x = " << x << " si y = " << y << endl;
                                return 0;
                            }
                    </xmp>
                    <p>Constatăm că deși în funcția cmmdc parametrii formali a și b se modifică, în main(), după apelul funcției cmmdc(), parametrii actuali x și y au valorile anterioare.</p>
                    <br><br>
                    <h4>B. Transmiterea prin referinta</h4>
                    <br>
                    <br>
                    <p>Este mecanismul specific C++ prin care putem modifica într-o funcție variabile din afara funcției. În cazul transmiterii parametrilor prin referință, parametrii formali ai unei funcții sunt referințe ale parametrilor actuali. Acest lucru înseamnă că:</p>                
                    <ul style="list-style-type:square;">
                        <li> parametri actuali pot fi doar variabile, sau expresii ale căror rezultate sunt similare variabilelor: elemente de tablou, câmp al unei structuri, pointer dereferențiat, etc.</li>
                        <li> pe stivă se memorează adresa variabilei date ca parametru actual.</li>
                        <li> toate modificările realizate în apelul funcției asupra parametrilor formali se fac de fapt asupra parametrilor actuali. Parametrii actuali sunt modificați la ieșirea din apel!</li>
                        <li> pentru a preciza că un parametru este transmis prin referință va fi precedat de caracterul & în antetul funcției.</li>
                    </ul>
                    <p> Trebuie amintit că în limbajul C nu este posibilă transmiterea parametrilor prin referință. Dacă dorim să modificăm într-o funcție o variabilă din afara ei trebuie să folosim pointeri.</p>
                    <h5> EXEMPLU:</h5> <br>
                    <xmp>
                        #include <iostream>
                        using namespace std;
                            
                            void dublare(int & n)
                            {
                                n = 2 * n;
                            }
                            
                            int main(){
                                int x = 24;
                                cout << "x = "  << x << endl;
                                dublare(x);
                                cout << "x = "  << x << endl;
                                return 0;
                            }
                    </xmp>
                    <p> Constatăm că, la ieșirea din apel, valoarea variabilei x este modificată. Mai mult, un apel de forma dublare(10); reprezintă o eroare de sintaxă, deoarece parametrul actual trebuie să fie variabilă.</p>
                    <br><br>
                    <h4>C. Transmiterea ca parametri a tablourilor</h4>
                    <br>
                    <p>Tablourile se transmit prin valoare, dar orice modificare a valorilor elementelor tabloului dat ca parametru formal va afecta elementul corespunzător al tabloului dat ca parametru actual.</p>
                    <h5>EXEMPLU:</h5>
                    <xmp>
                        #include <iostream>
                        using namespace std;
                            
                            void dublare(int & x)
                            {
                                x = 2 * x;
                            }
                            
                            void transf(int n, int  x[])
                            {
                                for(int i = 0 ; i < n ; i ++)
                                    dublare(x[i]);
                            }
                            
                            void afisare(int n, int  x[])
                            {
                                for(int i = 0 ; i < n ; i ++)
                                    cout << x[i] << " ";
                                cout << endl;
                            }
                            
                            int main(){
                                int n = 5, v[5];
                                for(int i = 0 ; i < n ; i ++)
                                v[i] = i;
                                afisare(n , v);     // tabloul memorează {0, 1, 2, 3, 4}
                                transf(n, v);
                                afisare(n , v);     // tabloul memorează {0, 2, 4, 6, 8}
                                return 0;
                            }
                    </xmp>
                    <p>Analizând programul anterior, constatăm că:</p>
                    <ul>
                        <li> am transmis prin referință funcției dublare() un element al tabloului.</li>
                        <li> funcția transf() are doi parametri transmiși prin valoare (inclusiv tabloul).</li>
                        <li> la ieșirea din apelul funcției transf() elementele tabloului sunt modificate, deși tabloul a fost transmis prin valoare.</li>
                    </ul>
                <br>
                <h4>D. Parametri de intrare, de iesire si de intrare/iesire</h4>
                <br>
                <br>
                <p>Așa cum am văzut deja, parametri sunt folosiți pentru a transfera date între subprograme. Astfel prin intermediul parametrilor o funcție poate să primească date pe care să le prelucreze sau poate să întoarcă rezultate în funcția care a făcut apelul.</p>
                <br>
                <br>
                <p> Din acest punct de vedere, parametrii unei funcții pot fi:</p>
                <ul>
                    <li> <b><i>parametri de intrare </i></b> - prin intermediul lor funcția primește date pe care să le prelucreze. De obicei sunt parametri transmiși prin valoare. Valoarea cu care intră în funcție este importantă, valoarea pe care o au la finalul apelului nu este importantă.</li>
                    <li> <b><i>parametri de ieșire </i></b> - prin intermediul lor funcția întoarce în programul apelant rezultate. De obicei sunt parametri transmiși prin referință, cu excepția tablourilor. Valoare pe care o au la intrarea în funcție nu este importantă; este importantă însă valoarea pe care o au la finalul apelului, deoarece reprezintă probabil rezultatul.</li>
                    <li> <b><i>parametri de intrare-ieșire </i></b> - prin intermediul lor funcția primește date de intrare, le prelucrează și tot prin intermediul lor întoarce rezultatul în programul apelant. De obicei sunt parametri transmiși prin referință, cu excepția tablourilor. Pentru acești parametri este importantă atât valoarea cu care intră în apel, cât și valoarea de la ieșirea din apel.</li>
                </ul>
            </div>
                </div>
            </div>
        </div>
    </div>

    

        <!-- Footer -->
        <svg class="footer-frame" data-name="Layer 2" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none" viewBox="0 0 1920 79"><defs><style>.cls-2{fill:#4da1ef;}</style></defs><title>footer-frame</title><path class="cls-2" d="M0,72.427C143,12.138,255.5,4.577,328.644,7.943c147.721,6.8,183.881,60.242,320.83,53.737,143-6.793,167.826-68.128,293-60.9,109.095,6.3,115.68,54.364,225.251,57.319,113.58,3.064,138.8-47.711,251.189-41.8,104.012,5.474,109.713,50.4,197.369,46.572,89.549-3.91,124.375-52.563,227.622-50.155A338.646,338.646,0,0,1,1920,23.467V79.75H0V72.427Z" transform="translate(0 -0.188)"/></svg>
        <div class="footer">
            <div class="container">
                <div class="row">
                    <div class="col-md-4">
                        <div class="footer-col first">
                            <h4>Despre site:</h4>
                            <p class="p-small">Realizat cu îndrumarea doamnelor profesoare de la liceul "Atanasie Marienescu" din Lipova.</p>
                        </div>
                    </div> <!-- end of col -->
                    <div class="col-md-4">
                        <div class="footer-col middle">
                            <h4>Important Links</h4>
                            <ul class="list-unstyled li-space-lg p-small">
                                <li class="media">
                                    <i class="fas fa-square"></i>
                                    <div class="media-body">Site-ul liceului <a class="white" href="http://www.lamlipova.ro/">www.lamlipova.ro</a></div>
                                </li>
                                
                            </ul>
                        </div>
                    </div> <!-- end of col -->
                    <div class="col-md-4">
                        <div class="footer-col last">
                            <h4>Contact</h4>
                            <ul class="list-unstyled li-space-lg p-small">
                                <li class="media">
                                    <i class="fas fa-map-marker-alt"></i>
                                    <div class="media-body">286, strada Soimos, Lipova, Arad, ROMANIA</div>
                                </li>
                                <li class="media">
                                    <i class="fas fa-envelope"></i>
                                    <div class="media-body"><a class="white" href="mailto:daniel.ben.cotoc@gmail.com">daniel.ben.cotoc@gmail.com</a> </div>
                                </li>
                            </ul>
                        </div> 
                    </div> <!-- end of col -->
                </div> <!-- end of row -->
            </div> <!-- end of container -->
        </div> <!-- end of footer -->  
        <!-- end of footer -->
        



   
    
    	
    <!-- Scripts -->
    <script src="js/jquery.min.js"></script> <!-- jQuery for Bootstrap's JavaScript plugins -->
    <script src="js/popper.min.js"></script> <!-- Popper tooltip library for Bootstrap -->
    <script src="js/bootstrap.min.js"></script> <!-- Bootstrap framework -->
    <script src="js/jquery.easing.min.js"></script> <!-- jQuery Easing for smooth scrolling between anchors -->
    <script src="js/swiper.min.js"></script> <!-- Swiper for image and text sliders -->
    <script src="js/jquery.magnific-popup.js"></script> <!-- Magnific Popup for lightboxes -->
    <script src="js/validator.min.js"></script> <!-- Validator.js - Bootstrap plugin that validates forms -->
    <script src="js/scripts.js"></script> <!-- Custom scripts -->
</body>
</html>